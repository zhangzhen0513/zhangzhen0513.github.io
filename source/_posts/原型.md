---
title: 原型
toc: true
date: 2019-09-27 20:36:04
updated: 2019-09-27 20:42:15
tags:
  - JavaScript
  - 原型
  - 原型链
  - 类
categories:
  - JavaScript
---
## 原型链

实例对象`p`/实例对象的构造函数`Person`:

- `p.__proto__` 指向 `Person` 的`perototype`(原型对象)

- `Person.prototype.__proto__` 指向 `Object.prototype`

- `Object.prototype.__proto__` 指向 `null`

- `Object.__proto__` 指向 `Function.prototype`

- `Function.__proto__` 指向 `Function.prototype` 

**特点就是，如果一个实例对象中的方法要调用时，那么先找实例对象，如果没有则沿着原形链继续找，直到找到或者没有找到，如果找到就调用，没有找到就说明没有**

<!-- more -->

## 原型函数实现继承

构造函数创建对象的方式

```javascript
function 构造函数 {
  // 属性写在构造函数里
  this.属性名 = "属性值"
}

// 方法写在原型对象上
构造函数.prototype.方法名 = function () {}
```

```javascript
function Person(name, age, sex) {
  this.name = name
  this.age = age
  this.sex = sex
}

Person.prototype.say = function () { 
  console.log(1);
}

function Student(name, age, sex, sid) {
  Person.call(this, name, age, sex)
  this.sid = sid
}

Student.prototype.study = function () {
  console.log(2);
}

// 实现方法的继承 直接修改原型链的指向，在原本原型链断开增加一条
Student.prototype.__proto__ = Person.prototype
// 或者
Student.prototype = new Person
```
## class

> ES6中的类是一个假类，实质上还是用构造函数实现

```javascript
// 这个Person叫类名
class Person {
  // 每个类都有构造函数
  constructor (name, age, sex) {
    // 属性写在构造函数里
    this.name = name
    this.age = age 
    this.sex = sex
  }

  // 方法直接写在类里
  say () {
    // 这就是方法
  }
}

// 进行继承
class Student extends Person{
  constructor (name, age, sex, sid) {
    // this.name = name
    // 调用super继承父类属性
    super(name, age, sex)
    this.sid = sid
  }

  study () { // 这个方法必须new 类名得到对象后调用
    console.log(1);
  }

  static study2 () {
    console.log(2);
  } // 静态方法会被添加到我们对应的类里，可以直接类名.方法名调用
}

const p = new Person('张三', 18, '男')
const s = new Student('李四', 20, '男', 1000)

console.log(p,s);

Student.study(); // Uncaught TypeError: Student.study is not a function
Student.study2(); // 2
s.study(); // 1
s.study2(); // Uncaught TypeError: s.study2 is not a function
```