{"pages":[],"posts":[{"title":"静态博客搭建","text":"Hexo初始化 Hexo 是基于node进行安装的 必备条件 Node.js Git 全局安装Hexo1$ yarn add -g hexo-cli 初始化hexo目录12345hexo init &lt;文件夹名&gt;cd &lt;文件夹名&gt;yarn 本地启动服务1hexo s 默认端口:4000 hexo 基础命令1234567891011# 清除文件hexo clean # 根据模板生成静态文件hexo g# 启动本地服务hexo s# 一键部署hexo d hexo d 需要进行一些相关配置，见下文 更换主题个人比较喜欢icarus，这个主题，在当前目录下，输入命令 12# 将主题文件克隆到 themes 文件夹下$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 修改_config.yml文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 之后运行命令 12# 如果报错，先运行hexo clean 然后hexo g，重新生成文件$ hexo s // start a live server 部署博客 github新建一个 repository。repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io。 安装git部署工具 1yarn add hexo-deployer-git 修改_config.yml文件 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #git@github.com:&lt;你的 GitHub 用户名&gt;/&lt;你的 GitHub 用户名&gt;.github.io.git branch: [branch] #默认master，可不填 message: [message] #部署时commit信息，可不填 一键部署 1hexo d 过几分钟查看https://&lt;你的 GitHub 用户名&gt;.github.io，就能看到自己博客啦~","link":"/2020-07-11-Hexo-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"原型","text":"原型链实例对象p/实例对象的构造函数Person: p.__proto__ 指向 Person 的perototype(原型对象) Person.prototype.__proto__ 指向 Object.prototype Object.prototype.__proto__ 指向 null Object.__proto__ 指向 Function.prototype Function.__proto__ 指向 Function.prototype 特点就是，如果一个实例对象中的方法要调用时，那么先找实例对象，如果没有则沿着原形链继续找，直到找到或者没有找到，如果找到就调用，没有找到就说明没有 原型函数实现继承构造函数创建对象的方式 1234567function 构造函数 { // 属性写在构造函数里 this.属性名 = \"属性值\"}// 方法写在原型对象上构造函数.prototype.方法名 = function () {} 1234567891011121314151617181920212223function Person(name, age, sex) { this.name = name this.age = age this.sex = sex}Person.prototype.say = function () { console.log(1);}function Student(name, age, sex, sid) { Person.call(this, name, age, sex) this.sid = sid}Student.prototype.study = function () { console.log(2);}// 实现方法的继承 直接修改原型链的指向，在原本原型链断开增加一条Student.prototype.__proto__ = Person.prototype// 或者Student.prototype = new Person class ES6中的类是一个假类，实质上还是用构造函数实现 12345678910111213141516171819202122232425262728293031323334353637383940414243// 这个Person叫类名class Person { // 每个类都有构造函数 constructor (name, age, sex) { // 属性写在构造函数里 this.name = name this.age = age this.sex = sex } // 方法直接写在类里 say () { // 这就是方法 }}// 进行继承class Student extends Person{ constructor (name, age, sex, sid) { // this.name = name // 调用super继承父类属性 super(name, age, sex) this.sid = sid } study () { // 这个方法必须new 类名得到对象后调用 console.log(1); } static study2 () { console.log(2); } // 静态方法会被添加到我们对应的类里，可以直接类名.方法名调用}const p = new Person('张三', 18, '男')const s = new Student('李四', 20, '男', 1000)console.log(p,s);Student.study(); // Uncaught TypeError: Student.study is not a functionStudent.study2(); // 2s.study(); // 1s.study2(); // Uncaught TypeError: s.study2 is not a function","link":"/2019-09-27-%E5%8E%9F%E5%9E%8B/"}],"tags":[{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"github.io","slug":"github-io","link":"/tags/github-io/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"原型","slug":"原型","link":"/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"原型链","slug":"原型链","link":"/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"类","slug":"类","link":"/tags/%E7%B1%BB/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"icarus","slug":"hexo/icarus","link":"/categories/hexo/icarus/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}